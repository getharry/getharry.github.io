# 和想做前端工程师的同学谈谈学习

### 一些有感
我们科学院每年都有很多年轻的实习生过来，看见他们朝气蓬勃，但却经常遇到问题又不知问题缘何而起，想写点东西给他们。  
我做前端差不多有七年时间了，这让我想到一个词，“七年之痒”，但用这个词似乎却不能准确地描述出我的感觉，那是一种别样的感觉。   
站在当下繁荣的前端圈，我们回溯历史时会产生一种这样的感觉：工具越来越多，生产力越来越发达，一切都在走向庞大和复杂，可趣味性和原生性似乎显得越来越弱了。   
我们正在花费巨量的时间去了解和学习不断新出的种种新知，却很难再有时间去关注基础层面、趣味层面、设计层面的问题了，尤其对于一些新入行的同学来说，
直接上手框架是百害而无一利的；对于老手来说，也可以问问自己，有多久没有用纯粹的原生js做一些简单的、动人心弦的效果了。

### 概念
曾有人问我什么叫执行上下文，它可以理解为当前代码的运行环境，一般我更喜欢谈及作用域。   
在js中，只有两只作用域：函数作用域和全局作用域。如果理解了这个，就能理解闭包吗，我想未必。
什么叫闭包？它的英文是Closures，其中有个sure，看来很先知，意思就是说你搞不明白它是冥冥中的一种必然，it's sure。  
按照万物皆对象的理念，我们可以把闭包理解为一种特殊的对象。在框架技术大行其道的今天，我们程序员其实也很少被闭包所左右了，因为
框架中明晰了严格的作用域范围，就像栽植秧苗之前我们已经有了理想的田地。其实我现在也经常是把它作为一种历史去谈及。      
下面通过一组代码演示一下闭包的概念，执行上下文foo，这使得foo中函数bar得以执行，它就会访问foo中的内部变量a和b，这时候就产生了闭包。
```javascript
function foo(){
    var a = 20;
    var b = 30;
    function bar(){
        return a + b;
    }
    return bar;
}
foo();
```
我们知道，js有自动的垃圾回收机制，所采用的算法叫做标记清除算法，当一个值失去引用之后就会被标记然后才能被垃圾回收机制
回收并释放空间。为了避免我们在写原生程序的时候会出现一些不必要的闭包场景，我们需要保持警惕性，那问题来了，如果让你写
一段代码来证明闭包不被垃圾回收，你会怎么写呢，下面举个例子，演示函数的局部变量的内存泄露。
```javascript
function f1(){
    var n = 999;
    nadd = function(){
        n += 1
    }
    return function f2(){
        console.log(n)
    }
}
f1(); // 999
nadd();
fi(); // 1000
```
未完待续。。。










